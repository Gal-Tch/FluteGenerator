import numpy as np
import cvxpy as cp
import matplotlib.pyplot as plt
import librosa
import librosa.display
import beeper
from pydub import AudioSegment


class FluteGenerator:
    def __init__(self):
        self.c = 343  # speed of sound in [m/sec]
        self.diameter_proportion = 0.1  # recommended diameter factor of the length of a pipe [meters]
        self.diameter_range = [1 / 14, 1 / 7]  # acceptable diameter as a factor of the length of a pipe
        self.compression_correction = 0.01  # will be substracted from the flute length to avoid flattening [meters]
        self.hole_size = (
            0.005  # the holes need to be large enough in order for the open-pipe assumptions to be correct [meters]
        )

    def mp3_to_wav_converter(self, path):
        sound = AudioSegment.from_mp3(path)
        sound.export(path.split(".")[0] + ".wav", format="wav")

    def freq_extractor(self, wav_path, first_n_seconds=10, plot_pitches=True, generate_beep_file=True, num_freqs=10):
        # Extracts the freqs from the song (main frequency in each time step)
        x, sr = librosa.load(wav_path, sr=None)
        # If it is desired to only use the first X seconds of a song
        if first_n_seconds != None:
            x = x[: first_n_seconds * sr]
            int(x.shape[0] / sr)
        secs_of_data = int(x.shape[0] / sr)

        # Determines the onset of notes in the song
        onsets = librosa.onset.onset_detect(y=x, sr=sr, units="time")
        # Detecting the pitches in each time step by STFT
        pitches, magnitudes = librosa.piptrack(y=x, sr=sr, n_fft=50000, fmin=200.0, fmax=2000.0)
        # Getting the pitch with the highest magnitude in each time step
        max_indexes = np.argmax(magnitudes, axis=0)
        pitches = pitches[max_indexes, range(magnitudes.shape[1])]

        pitches_dt = secs_of_data / pitches.shape[0]
        pitches_times = np.arange(pitches.shape[0]) * pitches_dt

        _, binned_freqs = np.histogram(pitches, bins=num_freqs)
        binned_freqs += 300 - binned_freqs[0]

        binned_freqs_idx = np.abs((pitches - binned_freqs[:, np.newaxis])).argmin(axis=0)
        pitches = binned_freqs[binned_freqs_idx]

        if plot_pitches:
            plt.plot(pitches)
            plt.show()

        # Generates an audio file with sine waves in the frequency of the maximum pitch in each timestep
        # Gives a notion of whether the extraction is successful or not
        if generate_beep_file:
            bg = beeper.BeepGenerator()
            for i in range(1, onsets.shape[0] - 2):
                duration = onsets[i + 1] - onsets[i]
                pitch_idx = np.abs((onsets[i] - pitches_times)).argmin()
                pitch = pitches[pitch_idx]
                bg.append_sinewave(freq=pitch, volume=1, duration_milliseconds=duration * 1000)

            bg.save_wav(wav_path.split(".")[0] + "_beeps.wav")

        binned_freqs = np.delete(binned_freqs, 0)
        return binned_freqs

    def design_flute(
        self,
        freqs,
        lower_length_limit=0.05,
        upper_length_limit=0.6,
        allow_holes=False,
        holes_lower_margin=0.05,
        holes_upper_margin=0.05,
        equal_difference_pipe_lengths_goal=False,
        equal_difference_hole_locations_goal=False,
        equal_difference_pipe_lengths_constraint=False,
        equal_difference_hole_locations_constraint=False,
        plot_flute=True,
        hole_locations_constraint=None,
    ):

        wavelengths = self.c / freqs  # helps with the quadratic program
        n = freqs.shape[0]

        # Defining the goals
        if allow_holes:
            open_wl = wavelengths[n // 2 :]  # wavelengths that will be generated by holes
            closed_wl = wavelengths[: n // 2]  # wavelengths that will be generated by closed pipes
            ls = cp.Variable(n // 2)
            hs = cp.Variable(n // 2)
            cost = cp.sum_squares(4 * ls - closed_wl) + cp.sum_squares(2 * hs - open_wl)

        else:
            closed_wl = wavelengths  # wavelengths that will be generated by holes
            ls = cp.Variable(n)
            cost = cp.sum_squares(4 * ls - closed_wl)

        if equal_difference_pipe_lengths_goal:
            cost += 5 * cp.sum_squares(ls[2:] - 2 * ls[1:-1] + ls[:-2])

        if allow_holes:
            if equal_difference_hole_locations_goal:
                cost += 5 * cp.sum_squares(hs[2:] - 2 * hs[1:-1] + hs[:-2])

        # Defining the constrains
        constraints = [lower_length_limit <= ls, ls <= upper_length_limit]
        if equal_difference_pipe_lengths_constraint:
            new_constraints = [ls[i + 2] - ls[i + 1] == ls[i + 1] - ls[i] for i in range(ls.shape[0] - 2)]
            constraints += new_constraints

        if allow_holes:
            constraints += [lower_length_limit + holes_lower_margin <= hs]
            constraints += [hs[i] <= ls[i] - holes_upper_margin for i in range(n // 2)]
            if equal_difference_hole_locations_constraint:
                new_constraints = [hs[i + 2] - hs[i + 1] == hs[i + 1] - hs[i] for i in range(hs.shape[0] - 2)]
                constraints += new_constraints
            if hole_locations_constraint != None:
                new_constraints = [
                    hs[i] - hole_locations_constraint[i] == 0 for i in range(hole_locations_constraint.shape[0])
                ]
                constraints += new_constraints

        prob = cp.Problem(cp.Minimize(cost), constraints)
        prob.solve()

        pipe_lengths = ls.value

        results = [pipe_lengths]

        if allow_holes:
            hole_locations = list(hs.value)
            results.append(hole_locations)

            # Printing results
            for i in range(n // 2):
                print(
                    f"flute {i}, pipe length {pipe_lengths[i]} with freq {self.c/(4*pipe_lengths[i])},"
                    f" hole location {hole_locations[i]} with freq {self.c/(2*hole_locations[i])}"
                )
        else:
            for i in range(n):
                print(f"flute {i}, pipe length {pipe_lengths[i]} with freq {self.c/(4*pipe_lengths[i])}")

        if plot_flute:
            if allow_holes:
                plt.bar(np.arange(n // 2), pipe_lengths)
                plt.scatter(np.arange(n // 2), hole_locations)
                plt.show()
            else:
                plt.bar(np.arange(n), pipe_lengths)
                plt.show()
        return results
